## 常量



### 常量的概念和类型



#### 常量的概念

常量就是在程序中不能改变其值的量



#### 常量的类型



##### 整型

1. **整型常量默认为`int`类型**
2. 例如：`10`就代表一个`int`类型的==十进制常量==
3. 像`012`这样的以`0`开头的表示一个`int`类型的==八进制常量==
4. 而`0x12`以`0x`开头就表示这是一个`int`类型的==十六进制常量==
5. 由于整型常量默认为`int`类型，所以如果想要表示一个`long`类型的常量，就需要在一个整型常熟后面加上`l`或者`L`表示这是一个`long`类型的常量
6. 而`u`作为后缀，表示这个整数是无符号`int`类型



##### 实型

1. **实型长常量默认为`double`类型**
2. 可以用小数形式或者是科学计数法的形式表示(例如`3.14`, `1.2e-5`)
3. 要表示一个实数属于`float`类型，必须在一个实数后面加上`f`或者`F`(例如`3.14F`)
4. 而要表示一个`long double`类型，则应该在一个实数后面加上一个`L`作为后缀



##### 字符型

使用一对单引号('')引起来的一个字符，就表示这是一个字符型常量



##### 字符串

一堆双引号("")括起来的内容，就是一个字符串常量



##### 枚举类型

------



### 幻数(Magic Number)



#### 幻数的概念

在程序中直接使用的常数,也就是一个字面量常量,这样的数称为==幻数==.例如

```c
#include <stdio.h>

int main(void)
{
    double area = 3.14 * 2 * 2;
    printf("%d\n", area);
    
    return 0;
}
```

- 上面例子中的`3.14`等常数就称为==幻数==



#### 使用幻数存在的问题

1. 程序的可读性差
2. 容易发生书写错误,产生不一致
3. 后期代码维护难度大



#### 如何在程序中避免使用幻数

1. 良好的程序设计风格应该把幻数定义为:
   - 宏常量
   - `const`常量
2. 将幻数定义为一个宏常量或者是`const`常量的好处就是
   - 能够减少重复书写常数的工作量,从而也能减少书写常数出错的可能性
   - 提高了代码的可读性和可维护性

------



### 宏常量



#### 宏常量的概念

使用一个标识符号来标识的常量



#### 宏定义

```c
#define 标识符 需要进行标识的字符串
```

- 其中`#`符号表示这是一条编译预处理指令
- ==编译预处理指令==表示这一条指令是在源代码被编译前就已经先被编译预处理程序进行处理过,然后将处理的结果和源代码一起进行编译最终获得目标代码
- `标识符`为符号常量,也成为宏名, 一般全大写
- `需要进行标识的字符串`就是要使用标识符进行标识的字符串,定义了一个宏之后,就可以在源代码中使用宏名代替`需要进行标识的字符串`



#### 宏展开、宏替换

1. 定义了一个宏之后，我们就可以在源代码中使用宏名来代替其标识的字符串

2. 在预编译的时候，预编译处理程序会将源程序中所有使用了宏名的地方展开和替换为其代表的字符。例如

   ```c
   #include <stdio.h>
   #define PI 3.14
   
   int main(void)
   {
       double area = PI * 2 * 2;
       printf("%d\n", area);
       
       return 0;
   }
   ```

   - 预编译处理之后，展开为

     ```c
     #include <stdio.h>
     #define PI 3.14
     
     int main(void)
     {
         double area = 3.14 * 2 * 2;
         printf("%d\n", area);
         
         return 0;
     }
     ```

     

3. 所以我们在宏定义的时候，末尾一般不要写`;`号，因为这并不是一条c语句

4. ==宏替换==实际上就是一个完完全全的纯文本替换，在进行预编译处理的时候，将宏名替换为它所 代表的字符串。如果我们像下面这样写

   ```c
   #define PI 3.14;
   
   ...
       
   double area = PI * 2 * 2;
   ```

   - 那替换后就变成了

     ```c
     #define PI 3.14;
     
     ...
         
     double area = 3.14; * 2 * 2;
     ```

   - 这样就会导致产生编译错误

5. 我们知道，双引号("")之间包含的内容是一个字符串常量，因此，对于字符串常量中出现的宏名，是不会进行宏展开和宏替换的。例如

```c
#define PI 3.14
...
printf("PI = %f\n", PI);
```

- 那么字符串常量中的`PI`是不会被进行宏展开和宏替换的。其宏替换结果为

```c
#define PI 3.14
...
printf("PI = %f\n", 3.14);
```





#### 宏常量存在的问题

1. 没有数据类型，进行宏替换的时候不进行类型检查
2. 宏替换就是简单的纯文本替换，容易产生意想不到的错误

------



### `const`常量



#### `const`常量的定义格式

```c
const DataType valueName = value;
```

- 这和变量的定义类似，前面用`const`来修饰，**同时还必须在定义的时候给该`const`常量赋初值**，因为这是定义一个常量，而常量是存储在只读区域的，因此必须在定义的同时赋初值



#### `const`常量的优势

`const`常量具有数据类型，编译器能够对其类型进行检查

------



### END

