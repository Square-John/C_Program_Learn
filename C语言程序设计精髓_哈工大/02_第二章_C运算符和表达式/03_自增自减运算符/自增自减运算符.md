## 自增自减运算符



### 自增自减运算符概念

1. 自增运算符：也叫增1运算符，`++`，使变量的值增加一个单位。

2. 自减运算符：也叫减1运算符，`--`，使变量的值减少一个单位。

3. 自增和自减运算符都是一元运算符。

4. 自增自减运算符有两种形式：

   1. 前缀(prefix)

      ```c
      ++n; -> n = n + 1;
      --n; -> n = n - 1;
      ```

      

   2. 后缀(postfix)

      ```c
      n++; -> n = n + 1;
      n--; -> n = n - 1;
      ```

      

5. 由上可见，自增自减运算符相当于先取出需要进行相应运算操作的变量的值，然后进行加1或者是减1操作，然后再将所得的结果重新赋值给该变量，将其写入到该变量的内存空间。

6. **因为自增自减运算符的等价形式中有一个赋值的操作，而赋值操作的左值不允许是表达式，所以，自增自减运算符的操作数只能是变量，不能是常量或者表达式**。

7. 我们可以看到，自增自减运算符的前缀和后缀形式对于其操作数的结果都是一样的，都是使其操作数增1或者减1，前缀和后缀形式会影响其参与的运算的结果。



### 前缀自增自减运算符

1. 作为==前缀==运算符

   1. 形式：`++n`, `--n`
   2. 含义：先对`n`进行自增或者自减，然后将自增自减之后的结果写入到`n`的变量空间中，然后再使用自增或者自减之后的`n`参与其他运算。

2. 例子：

   ```c
   m = ++n;
   /**
   这等价于：
   	1、先执行 n = n + 1;
   	2、然后 m = n;
   */
   ```

   

### 后缀自增自减运算符

1. 作为==后缀==运算符
   1. 形式：`n++`, `n--`
   2. 含义：先取出`n`的值参与其他运算，等`n`参与的运算进行完毕，再将`n`自增或者自减1，然后再将变化后的值重新赋值给`n`
2. 例子：

```c
m = n++;
/**
这等价于:
	1、先取出n的值参与运算 m = n;
    2、然后再进行自增 n = n + 1;
*/
```



### 一些注意事项

1. 一元运算符的优先级高于二元运算符，一元算术运算符的优先级高于一元逻辑运算符，二元算术运算符的优先级也是高于二元逻辑运算符的。==一元运算符==的结合性是==右结合==，而**二元运算符**是**左结合**的。
2. 自增自减运算符的前缀或者后缀形式影响的是其作为子表达式的表达式的运算结果，对于自增自减的操作数自身是一样的，其结果都是使自己自增或者自减1。



### 总结

1. 不论使是前缀还是后缀形式的自增自减运算符，对于其操作数的结果都是一样的，都使其操作数自增或者自减1。

2. 前缀形式的自增自减运算符，相当于先对其操作数进行自增或者是自减1，然后再将自增之后的结果用于参与其他运算，而后缀形式是，先取自增自减运算符的操作数参与其他运算，待其他运算完毕之后再对该操作数进行自增或者自减操作。**也就是，前缀是先对自己自增自减，然后再将新值和其他运算分享，后缀是先将自己分享给其他运算，等使用完毕之后再自己进行自增自减**

3. 自增自减运算符生成的代码一般效率都会相较于其等价形式高一些。

4. 如果一条语句中，出现过多的自增自减运算符，可能会导致代码的可读性变差，而且可能依赖编译器，例如下面这样的语句：

   ```c
   int a = 1;
   int b = 1;
   b = ++a * --a;
   ```

   我们都知道，一元运算符的优先级高于二元运算符，所以上面的语句中`*`运算肯定是最后进行，但是对于其左右的`++a`和`--a`不同的编译器其执行顺序可能不一样，有的可能先执行`++a`，有的可能先执行`--a`，这就导致同一条语句，在不同的编译环境下会产生不同的结果。

5. ==良好的程序设计风格提倡==：在一条语句中，一个变量只出现一次自增或者是自减运算

### END

